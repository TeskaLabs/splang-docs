---
title: Date/time 
---

# SP-Lang date/time 

Type `datetime` is a value that represents a date and time in the UTC, using broken time structure.
Broken time means that year, month, day, hour, minute, second and microsecond are stored in dedicated fields; different from the e.g. UNIX timestamp.

* Timezone: [UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)
* Resolution: microseconds (six decimal digits)

!!! tip "Usefull tools"

		* [UNIX Timestamp](https://www.unixtimestamp.com)
		* [UTC to/from local time convertor](https://www.worldtimebuddy.com)


## Bit layout

The datetime is stored in 64bit unsigned integer (`ui64`); little-endian format, Intel/AMD 64bit native.

<img src="../date-time-bit-layout.jpg" alt="Schema of the data/time bit layout" />

<table>
<thead>
	<tr>
		<th>Position</th>
		<th>Component</th>
		<th>Bits</th>
		<th>Mask</th>
		<th>Type*</th>
		<th>Range</th>
		<th>Remark</th>
	</tr>
</thead>
<tbody>
	<tr style="border-top: 2px solid gray; background-color: #d0cecf;">
		<td>58-63</td>
		<td></td>
		<td>4</td>
		<td></td>
		<td></td>
		<td>0…15</td>
		<td>OK (0)/Error (8)/Reserved</td>
	</tr>
	<tr style="border-top: 1px solid gray; background-color: #f1ccb1;">
		<td>46-57</td>
		<td>year</td>
		<td>14</td>
		<td></td>
		<td><code>si16</code></td>
		<td>-8190…8191</td>
		<td></td>
	</tr>
	<tr style="border-top: 1px solid gray; background-color: #fbe6a3;">
		<td>42-45</td>
		<td>month</td>
		<td>4</td>
		<td>0x0F</td>
		<td><code>ui8</code></td>
		<td>1…12</td>
		<td>Indexed from 1</td>
	</tr>
	<tr style="border-top: 1px solid gray; background-color: #fcf2cf;">
		<td>37-41</td>
		<td>day</td>
		<td>5</td>
		<td>0x1F</td>
		<td><code>ui8</code></td>
		<td>1…31</td>
		<td>Indexed from 1</td>
	</tr>
	<tr style="border-top: 1px solid gray; background-color: #c1d5ed;">
		<td>32-36</td>
		<td>hour</td>
		<td>5</td>
		<td>0x1F</td>
		<td><code>ui8</code></td>
		<td>0…24</td>
		<td></td>
	</tr>
	<tr style="border-top: 1px solid gray; background-color: #dfebf7;">
		<td>26-31</td>
		<td>minute</td>
		<td>6</td>
		<td>0x3F</td>
		<td><code>ui8</code></td>
		<td>0…59</td>
		<td></td>
	</tr>
	<tr style="border-top: 1px solid gray; background-color: #cbe0b9;">
		<td>20-25</td>
		<td>second</td>
		<td>6</td>
		<td>0x3F</td>
		<td><code>ui8</code></td>
		<td>0…60</td>
		<td>60 is for leap second</td>
	</tr>
	<tr style="border-top: 1px solid gray; border-bottom: 1px solid gray; background-color: #e3eedd;">
		<td>0-19</td>
		<td>microsecond</td>
		<td>20</td>
		<td></td>
		<td><code>ui32</code></td>
		<td>0…1000000</td>
		<td></td>
	</tr>
</tbody>
</table>


!!! note

	*) Type is	recommended/minimal byte-aligned type for a respective component.


## Timezone details

Timezone information originates from [pytz](http://pytz.sourceforge.net) respectively from the [IANA Time Zone Database](https://www.iana.org/time-zones).

!!! note

		The time zone database has precision down to the minute, it means that seconds and microseconds remain untouched when converting from/to UTC._

The timezone data is represented by a filesystem directory structure commonly located at `/usr/share/splang` or at location specified by `SPLANG_SHARE_DIR` environment variable.
The actual timezone data are stored at `tzinfo` subfolder.
The timezone data are generated by a script `generate_datetime_timezones.py` during installation of SPLang.

!!! example "Example of the `tzinfo` folder"

		```
		.
		└── tzinfo
		  ├── Europe
		    │  ├── Amsterdam.sptl
		    │  ├── Amsterdam.sptb
		    │  ├── Andorra.sptl
		    │  ├── Andorra.sptb
		```

`.sptl` and `.sptb` files contains speed-optimized binary tables that supports fast lookups for local time <-> UTC conversions.
`.sptl` is for little-endian CPU architectures (x86 and x86-64), `.sptb` is for big-endian architectures.

The file is [memory-mapped](https://en.wikipedia.org/wiki/Memory-mapped_file) into the SP-Lang process memory space, aligned on 64byte boundary, so that it can be directly used as a lookup.

### Common structures

  * `ym`: Year & month, `ym = (year << 4) + month`
  * `dhm`: Day, hour & minute, `dhm = (day << 11) + (hour << 6) + minute`

Both structures are bit-wise parts of the `datetime` scalar value and can be extracted from `datetime` using `AND` and `SHR`.**

### Timezone file header

Header length in 64 bytes.
Unspecified bytes are set to `0` and reserved for a future use.

  * Position `00...03`: `SPt` / magic identifier
  * Position `04`: `<` for little-endian CPU architecture, `>` for big-endian
  * Position `05`: Version (currently `1` ASCII character)
  * Position `08...09`: Minimal year/month (`min_ym`) in this file, month MUST BE 1
  * Position `10...11`: Maximal year/month (`min_ym`) in this file
  * Position `12...15`: The position of the "parser table" in the file, multiplied by 64, typically `1` b/c the parser table is stored directly after a header


### Timezone parser table

The _parser table_ is a lookup table used for conversion from the local date/time into UTC.

<img src="../date-time-ptable.jpg" alt="Organisation of the parser table" style="width: 461px;" />

The table is organised into rows/years and columns/months.
The cell is 4 bytes wide, the row is then 64 bytes long.

First 12 cells are "primary parser cells" (in light blue color), the number reflect the number of the month (1...12).
The remaining 4 cells are "parser next cells", the number `nX` is the index.

### Primary parser cell

The position of the cell for a given date/time is calculated as `pos = (ym - min_ym) << 5` which means that year and month is used for a cell localization, minus the minimal year&month value for a table.

Structure of the cell:
  * `16` bits: range, 16bits, `dhm`
  * `3` bits: `next`
  * `7` bits: hour offset from UTC
  * `6` bits: minute offset from UTC

`dhm` denotes the day, hour and minute in the year/month, when the time change (e.g. Daylight-saving time start/end) is observed.
For a typical month - where there is no time change is observed - the `dhm` value represents the maximum in the given month.

If `dhm` for a input date/time is mathematically lower than `dhm` from the primary cell, then the `hour` and `minute` information is used to adjust date/time from local to UTC.

If `dhm` is greater, then the `next` contains a number of the "parser next cell"; present at the end of the relevant parser table row.


### Parser next cell

The "parser next cell" contain a "continuation" of the information for a month where the time change is observed.
The "continuation" means the offset from UTC that happens when local time passed time change boundary.

Structure of the cell:
  * `16` bits: range, 16bits, `dhm`
  * `3` bits: not used, set to 0
  * `7` bits: hour offset from UTC
  * `6` bits: minute offset from UTC


`dhm` denotes the day, hour and minute in the year/month, when the NEXT time change (e.g. Daylight-saving time start/end) is observed.
Because currently we only support the single time change in the month, this field is set to maximum `dhm` for a given month.

The `hour` and `minute` information is used to adjust date/time from local to UTC.

_Note: currently, only one time change per month is supported, which seems to be fully sufficient for all info in IANA time zone database._

Empty/unused next cells are zeroed.


## Errors

If `datetime` bit 63 is set, then the date/time value represents an error.
Likely the expression that produced this value failed in some way.

The error code is stored in lower 32bits.

